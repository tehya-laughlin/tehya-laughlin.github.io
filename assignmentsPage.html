<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Projects</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
  </head>
  <body>

    <div class="box">
      <a href="./index.html"><img class="image3" src="./img/monograms/Black-Monogram.png" alt="Monogram TNL"></a>
      <h4><a href="./AboutMe.html">About Me</a></h4>
      <h4><a href="./assignmentsPage.html">Projects</a></h4>
      <h4><a href="./art.html">Art</a></h4>
      <h4><a href="./contactPage.html">Contact</a></h4>
    </div>

    <div>
    <h2>Projects<h2>
    </div>

<div class="NoScroll">
<div class="wrapper">
  <div class="aside">
    <div class="ulBar">
      <p class="liStyle"><a href="#atls2200">ATLS 2200</a></p>
      <p class="liStyle"><a href="#designfoundations">Design Foundations</a></p>
      <p class="liStyle"><a href="#appm3170">Infecious Disease Modeling</a></p>
      <p class="liStyle"><a href="#cmdgame">Command Line Game</a></p>
    </div>
  </div>

  <main>
    <div class="wrapper_inner">
        <h3 class="hLC" id="atls2200">ATLS 2200 Assignments:</h3>

        <div class="lLC">
          <ul class="pLCBox">
            <li><a href="./assignments/assignment_1.html">Assignment 1</a></li>
            <li><a href="./assignments/assignment_2.html">Assignment 2</a></li>
            <li><a href="./assignments/assignment3.html">Assignment 3</a></li>
            <li><a href="./assignments/assignment4.html">Assignment 4</a></li>
            <li><a href="./assignments/assignment5.html">Assignment 5</a></li>
            <li><a href="./assignments/assignment11.html">Assignment 11</a></li>
            <li><a href="./assignments/assignment12.html">Assignment 12</a></li>
          </ul>
        </div>

        <hr>


        <!--ATLAS Design Foundations-->
        <h3 class="hLC2" id="designfoundations">ATLAS Design Foundations</h3>
          <div class="pLCBox">
            <p>My <a href="https://tehyalaughlinblog.wordpress.com">Design Foundations Work In Progress</a> site holds my documentation for various projects I worked on during the class. This class covered multiple different topics, but stayed with the basic ideas surrounding design, like space, color, content, and the stages of the Ideation process. The final project for this class was to design an app, and use Adobe XD to create an interactive prototype. Adobe XD is great for basic prototypes, but I definitely found that it laking in some user-input areas. I was excited to learn more about Web developemnet from ATLS 2200.</p>
          </div>

          <hr>

        <!--APPM 3170 Project-->
        <h3 class="hLC2" id="appm3170">APPM 3170: Modeling Infection Growth with Data Science</h3>
          <div class="pLCBox">
            <p>I took APPM 3170 in the Fall of 2021. This class was about Discrete Mathematics, and we did a project using statistics and Graph theory to model the growth of an infectious disease
              in different settings and with two different types of data collection methods. This project seemed very relevant due to the Covid-19 pandemic, and highlighted the very interesting science that goes on behind disease tracking and statistical transmission. The project was tough and focused on the Graph data structure. My partner and I used MATLAB to write the simulation algorithm SIR. The two collection methods were face-to-face transmission, which was collected by the subjects wearing cameras on their chests as they went about their normal days. The second method was RFID tracking, like what our phones use to track location. The face-to-face tracking is the golden standard, and the project shows that simulating disease based off of this measure is moe accurate. You can acess the PDFs <a href="./documents/APPM3170.pdf#toolbar=0">HERE</a> and <a href="./documents/part2.pdf#toolbar=0">HERE</a>
              if the display below is too small.</p>
            <iframe src="./documents/APPM3170.pdf#toolbar=0" width="100%" height="800px"></iframe>
            <iframe src="./documents/part2.pdf#toolbar=0" width="100%" height="800px"></iframe>
          </div>

          <hr>

        <!--Comp Sci Game On standby until adding embedded command line ???? -->
        <h3 class="hLC2" id="cmdgame">CSCI 1300: Command Line RPG Dungeon Game</h3>
        <div class="pLCBox">
          <p>The final project for my first college coding class was to create a game that played through the terminal with the command line. The goal was to create the game and print a map and menu to the terminal, then take user input to move
          a character around the printed map. We were given the coded Map class, but then everything else about the game we had to create ourselves. We were allowed to work with parnters. Immediately after learning about the project, Joanna Parker and I decided to be partners. We initially had different ideas for the project, but then we decided on an RPG game. The first step was to think about what our project would contain, and how it would function. Then we organized how we would work together collaboratively. Github was important to this project because we could make a private repository and see commits/what the other partner changed. The repository also allowed for a project, with Kanban tabs, and cards that could be moved between tabs, which helped us keep on track since it was a dynamic to-do list. After setting up our configuration, we started on the class components. We knew we needed a player class, a monster class, and somehow an item/inventory class. Our class components grew and changed over the first week and after our design interview. For example, we originally had an item class, with swords, and potions being classes that inherited from Item. However, we also had an inventory where each item was stored and organized. After the design meeting, we got rid of the item and potion classes, but we kept the sword class and fed a sword vector into the inventory class. The potions ended up being variables, since what each potion did was constant.
        </p>
        <p>The code skeleton developed off of the class components, but we also added member functions and some variables later on. We first developed the map class changes, like changing hacker(from the default game names) to monster, npc to merchant, and best buy to coin. In this process, we realized that the map class needed some changes, like the map would include adjacent tiles in the is_Location() member function for the merchant and monsters. However, we didn’t change isCoinLocation(), because the idea of picking up a coin by the player being on the coin tile was what we wanted. Thinking about the map class also led us to develop the larger map of the game. There would be separate merchant rooms, and then also separate monster rooms. We also included doors, denoted by “/” in the map, which then the player could move through to load a new room. Our code skeleton started with the skeletons for the classes, the changes to the map class, and then also a skeleton for the Main Driver, which the game would be compiled and run from. The menu would be a switch containing all menu options, each switch calling on different functions that we would then develop separately. We definitely used the code skeleton to structure the larger ideas. However, we developed the functions for the menu options, ie. Attack, Defend, Pick Up, and the in-between utility functions, ie. Sorting, without a skeleton, because we used more individual pseudocode and intuition to figure out the small details.
        </p>
        <p>My partner and I developed the external functions to do with the menu, sorting, and map generation in a single file, functions.cpp. This was partially because some of them called on each other, and partially so that be put the class headers that were necessary in one file, and then the main driver only would include the functions.cpp file. We encountered some issues with classes including each other, and we could have had an issue with that if our classes were more intertwined, but we figured out the include order for the classes through some testing. While we didn’t have issues developing the classes and testing those, we did have issues testing the functions. We ended up testing only a couple in other driver files, but then just copied and pasted them in functions.cpp at the end when we were building out the Main Driver. The testing for the sorting functions, split function, and rand() implementations was thorough. However, all the other functions were mass-tested after the Main Driver was built through user testing. If we made and tested the functions more separately, we probably wouldn’t have had nearly as many bugs that ended up not being solved because of time running out. While it may have taken slightly longer, we probably wouldn’t have spent as much time trying to debug issues that stemmed from lazy coding. Otherwise, the choice to develop the functions before the Main Driver turned out to be a good choice because the Main Driver needed a lot of them to have full functionality. In this way, we had a complete driver when we started testing, so if there was an issue, we knew exactly which switch branch it came from, so then we knew which function had the issue.
        </p>
        <p>Joanna and I never had any false starts other than just dynamic changes to the initial class structure at the beginning of the process. However, some problems with the way we organized ourselves made some errors persistent and led us to have to cut out some parts of the project to make it more playable as a final result. I think the main reason we didn’t have false starts was because we thoroughly layed out the game’s specific play style, structure, and functionality before we started building out the skeleton. We also had great communication with each other, and looked at the Carmen Sandiego default game so we knew exactly what we needed to include. As a specific example, we planned out our game around the project requirements, and the added difficulty based on the Carmen Sandiego project, like the specific end games the user could encounter. The end games were that the user’s sword couds break, the user could quit, the user could die, or the user could defeat all 25 monsters and win the game. Based on the player's death and player win end games, we could develop the combat functionality. The combat functionality we also included rand() to make the fighting aspect have more depth and player strategy. Also, because we planned out the way we were going to use the map class, we also had a visual idea of what we could do. By following the project requirements for reading in files, we also helped ourselves by not hard coding the Monster object array, and the Sword object vector. Joanna and I also planned our use of github so we weren’t overwriting each other’s work, and we worked on separate aspects to really help pace ourselves and split up the work. However, just because we had no false starts doesn’t mean we had areas of friction or persistent bugs in the code. For example, all our functions were based on changing the input parameters, instead of returning the newly changed variable, because most functions changed  more than one parameter. I forgot to add ampersands to a lot of the changed parameters, so we had a lot of issues. Around 50% of our bugs were probably from not using passing by reference correctly. Then, we had some initial errors with some Inventory class aspects that ended up with some segmentation faults in the Main Driver. During our debugging process, we also had to do deep dives into issues, which included going into our classes and changing minor things. For example, we have a member function for Inventory called readInSwords, which takes in the swords.txt file name to make a vector of swords via a modified split function. However, instead of modifying/adding sword objects to the Inventory’s data member swordVector, it added it to a local vector for sword objects. In short, the readInSwords was not reading the swords into the right vector. This was a hard bug to catch because it is only an issue for the merchant menu of buying/selling a sword. This is because the player’s inventory has a single sword manually added to the player inventory’s swordVector, which doesn’t use the readInSwords function. Another issue we had was with spawning two monsters into a map. The isMonsterLocation would never catch the second monster, so combat actions didn’t work against it. We ended up having to get rid of loading 2-monster rooms because of this issue, which affected too much of the gameplay. Overall, there were no false starts, just a lot of bugs. We weren’t able to fix all the bugs, but we fixed up the game to be as playable as possible.
        </p>
        </div>

        <!--IMAGE project-->

      </div>
    </main>
  </div>
</div>
  </body>
</html>
